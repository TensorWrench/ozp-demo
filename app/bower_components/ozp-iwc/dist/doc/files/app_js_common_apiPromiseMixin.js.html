<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/js/common/apiPromiseMixin.js - ozpIwc</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="ozpIwc"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/ozpIwc.AjaxPersistenceQueue.html">ozpIwc.AjaxPersistenceQueue</a></li>
            
                <li><a href="../classes/ozpIwc.ApiBase.html">ozpIwc.ApiBase</a></li>
            
                <li><a href="../classes/ozpIwc.ApiError.html">ozpIwc.ApiError</a></li>
            
                <li><a href="../classes/ozpIwc.apiFilter.html">ozpIwc.apiFilter</a></li>
            
                <li><a href="../classes/ozpIwc.apiFilter.Function.html">ozpIwc.apiFilter.Function</a></li>
            
                <li><a href="../classes/ozpIwc.ApiNode.html">ozpIwc.ApiNode</a></li>
            
                <li><a href="../classes/ozpIwc.AsyncAction.html">ozpIwc.AsyncAction</a></li>
            
                <li><a href="../classes/ozpIwc.BadActionError.html">ozpIwc.BadActionError</a></li>
            
                <li><a href="../classes/ozpIwc.BadContentError.html">ozpIwc.BadContentError</a></li>
            
                <li><a href="../classes/ozpIwc.BadRequestError.html">ozpIwc.BadRequestError</a></li>
            
                <li><a href="../classes/ozpIwc.BadResourceError.html">ozpIwc.BadResourceError</a></li>
            
                <li><a href="../classes/ozpIwc.BadStateError.html">ozpIwc.BadStateError</a></li>
            
                <li><a href="../classes/ozpIwc.CancelableEvent.html">ozpIwc.CancelableEvent</a></li>
            
                <li><a href="../classes/ozpIwc.Client.html">ozpIwc.Client</a></li>
            
                <li><a href="../classes/ozpIwc.ClientParticipant.html">ozpIwc.ClientParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.CommonApiBase.html">ozpIwc.CommonApiBase</a></li>
            
                <li><a href="../classes/ozpIwc.CommonApiCollectionValue.html">ozpIwc.CommonApiCollectionValue</a></li>
            
                <li><a href="../classes/ozpIwc.CommonApiValue.html">ozpIwc.CommonApiValue</a></li>
            
                <li><a href="../classes/ozpIwc.DataApi.html">ozpIwc.DataApi</a></li>
            
                <li><a href="../classes/ozpIwc.DataNode.html">ozpIwc.DataNode</a></li>
            
                <li><a href="../classes/ozpIwc.Endpoint.html">ozpIwc.Endpoint</a></li>
            
                <li><a href="../classes/ozpIwc.EndpointRegistry.html">ozpIwc.EndpointRegistry</a></li>
            
                <li><a href="../classes/ozpIwc.Event.html">ozpIwc.Event</a></li>
            
                <li><a href="../classes/ozpIwc.FragmentPacket.html">ozpIwc.FragmentPacket</a></li>
            
                <li><a href="../classes/ozpIwc.FragmentStore.html">ozpIwc.FragmentStore</a></li>
            
                <li><a href="../classes/ozpIwc.IntentsApi.html">ozpIwc.IntentsApi</a></li>
            
                <li><a href="../classes/ozpIwc.IntentsInFlightNode.html">ozpIwc.IntentsInFlightNode</a></li>
            
                <li><a href="../classes/ozpIwc.InternalParticipant.html">ozpIwc.InternalParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.KeyBroadcastLocalStorageLink.html">ozpIwc.KeyBroadcastLocalStorageLink</a></li>
            
                <li><a href="../classes/ozpIwc.LeaderGroupParticipant.html">ozpIwc.LeaderGroupParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.Lifespan.Bound.html">ozpIwc.Lifespan.Bound</a></li>
            
                <li><a href="../classes/ozpIwc.Lifespan.Ephemeral.html">ozpIwc.Lifespan.Ephemeral</a></li>
            
                <li><a href="../classes/ozpIwc.Lifespan.Persistent.html">ozpIwc.Lifespan.Persistent</a></li>
            
                <li><a href="../classes/ozpIwc.LocksApi.html">ozpIwc.LocksApi</a></li>
            
                <li><a href="../classes/ozpIwc.LocksApiValue.html">ozpIwc.LocksApiValue</a></li>
            
                <li><a href="../classes/ozpIwc.log.html">ozpIwc.log</a></li>
            
                <li><a href="../classes/ozpIwc.MetricsRegistry.html">ozpIwc.MetricsRegistry</a></li>
            
                <li><a href="../classes/ozpIwc.metricsStats.Sample.html">ozpIwc.metricsStats.Sample</a></li>
            
                <li><a href="../classes/ozpIwc.metricsStats.UniformSample.html">ozpIwc.metricsStats.UniformSample</a></li>
            
                <li><a href="../classes/ozpIwc.metricStats.html">ozpIwc.metricStats</a></li>
            
                <li><a href="../classes/ozpIwc.metricStats.BinaryHeap.html">ozpIwc.metricStats.BinaryHeap</a></li>
            
                <li><a href="../classes/ozpIwc.metricStats.ExponentiallyDecayingSample.html">ozpIwc.metricStats.ExponentiallyDecayingSample</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.BaseMetric.html">ozpIwc.metricTypes.BaseMetric</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Counter.html">ozpIwc.metricTypes.Counter</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Gauge.html">ozpIwc.metricTypes.Gauge</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Histogram.html">ozpIwc.metricTypes.Histogram</a></li>
            
                <li><a href="../classes/ozpIwc.metricTypes.Meter.html">ozpIwc.metricTypes.Meter</a></li>
            
                <li><a href="../classes/ozpIwc.MulticastParticipant.html">ozpIwc.MulticastParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.NamesApi.html">ozpIwc.NamesApi</a></li>
            
                <li><a href="../classes/ozpIwc.NamesNode.html">ozpIwc.NamesNode</a></li>
            
                <li><a href="../classes/ozpIwc.NetworkPacket.html">ozpIwc.NetworkPacket</a></li>
            
                <li><a href="../classes/ozpIwc.NoActionError.html">ozpIwc.NoActionError</a></li>
            
                <li><a href="../classes/ozpIwc.NoMatchError.html">ozpIwc.NoMatchError</a></li>
            
                <li><a href="../classes/ozpIwc.NoPermissionError.html">ozpIwc.NoPermissionError</a></li>
            
                <li><a href="../classes/ozpIwc.NoResourceError.html">ozpIwc.NoResourceError</a></li>
            
                <li><a href="../classes/ozpIwc.PacketRouter.html">ozpIwc.PacketRouter</a></li>
            
                <li><a href="../classes/ozpIwc.packetRouter.html">ozpIwc.packetRouter</a></li>
            
                <li><a href="../classes/ozpIwc.Participant.html">ozpIwc.Participant</a></li>
            
                <li><a href="../classes/ozpIwc.Peer.html">ozpIwc.Peer</a></li>
            
                <li><a href="../classes/ozpIwc.policyAuth.PDP.html">ozpIwc.policyAuth.PDP</a></li>
            
                <li><a href="../classes/ozpIwc.policyAuth.SecurityAttribute.html">ozpIwc.policyAuth.SecurityAttribute</a></li>
            
                <li><a href="../classes/ozpIwc.PostMessageParticipant.html">ozpIwc.PostMessageParticipant</a></li>
            
                <li><a href="../classes/ozpIwc.PostMessageParticipantListener.html">ozpIwc.PostMessageParticipantListener</a></li>
            
                <li><a href="../classes/ozpIwc.Router.html">ozpIwc.Router</a></li>
            
                <li><a href="../classes/ozpIwc.RouterWatchdog.html">ozpIwc.RouterWatchdog</a></li>
            
                <li><a href="../classes/ozpIwc.standardApiFilters.html">ozpIwc.standardApiFilters</a></li>
            
                <li><a href="../classes/ozpIwc.SystemNode.html">ozpIwc.SystemNode</a></li>
            
                <li><a href="../classes/ozpIwc.Timer.html">ozpIwc.Timer</a></li>
            
                <li><a href="../classes/ozpIwc.TransportPacket.html">ozpIwc.TransportPacket</a></li>
            
                <li><a href="../classes/ozpIwc.TransportPacketContext.html">ozpIwc.TransportPacketContext</a></li>
            
                <li><a href="../classes/ozpIwc.util.html">ozpIwc.util</a></li>
            
                <li><a href="../classes/ozpIwcPolicies.html">ozpIwcPolicies</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/bus.html">bus</a></li>
            
                <li><a href="../modules/bus.api.html">bus.api</a></li>
            
                <li><a href="../modules/bus.api.Type.html">bus.api.Type</a></li>
            
                <li><a href="../modules/bus.api.Value.html">bus.api.Value</a></li>
            
                <li><a href="../modules/bus.network.html">bus.network</a></li>
            
                <li><a href="../modules/bus.network.packets.html">bus.network.packets</a></li>
            
                <li><a href="../modules/bus.security.html">bus.security</a></li>
            
                <li><a href="../modules/bus.service.html">bus.service</a></li>
            
                <li><a href="../modules/bus.service.Type.html">bus.service.Type</a></li>
            
                <li><a href="../modules/bus.service.Value.html">bus.service.Value</a></li>
            
                <li><a href="../modules/bus.service.Value.Persistance.html">bus.service.Value.Persistance</a></li>
            
                <li><a href="../modules/bus.transport.html">bus.transport</a></li>
            
                <li><a href="../modules/bus.util.html">bus.util</a></li>
            
                <li><a href="../modules/client.html">client</a></li>
            
                <li><a href="../modules/common.html">common</a></li>
            
                <li><a href="../modules/metrics.html">metrics</a></li>
            
                <li><a href="../modules/metrics.statistics.html">metrics.statistics</a></li>
            
                <li><a href="../modules/metrics.types.html">metrics.types</a></li>
            
                <li><a href="../modules/ozpIwc.html">ozpIwc</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: app/js/common/apiPromiseMixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * @method ozpIwc.ApiPromiseMixin
 * @static
 * Augments a participant or connection that supports basic IWC communications
 * functions for sending and receiving.
 * @uses ozpIwc.Events
 * @param {ozpIwc.Participant} participant
 */
ozpIwc.ApiPromiseMixin=function(participant,autoConnect) {
    autoConnect = (typeof autoConnect === &quot;undefined&quot; || autoConnect);

    participant.address = participant.address || &quot;$nobody&quot;;
    participant.connect = participant.connect ||  function(){
        participant.connectPromise = Promise.resolve();

        return participant.connectPromise;
    };

    if(!participant.events) {
        participant.events = new ozpIwc.Event();
        participant.events.mixinOnOff(participant);
    }

    var mixins = ozpIwc.ApiPromiseMixin.getCore();
    for(var i in mixins){
        participant[i] = mixins[i];
    }

    participant.readLaunchParams(window.name);
    participant.readLaunchParams(window.location.search);
    participant.readLaunchParams(window.location.hash);

    ozpIwc.ApiPromiseMixin.registerEvents(participant);

    participant.constructApiFunctions();

    if(autoConnect){
        participant.connect();
    }
};

/**
 * Registers event listeners for the participant.  Listens for the following events: disconnect.
 * @method registerEvents
 * @static
 * @param {ozpIwc.Participant} participant
 */
ozpIwc.ApiPromiseMixin.registerEvents = function(participant){
    participant.on(&quot;disconnect&quot;,function(){
        participant.promiseCallbacks={};
        participant.registeredCallbacks={};
        window.removeEventListener(&quot;message&quot;,participant.postMessageHandler,false);
        participant.connectPromise = null;
    });
};

/**
 * A factory for the apiPromise functionality.
 *
 * @method getCore
 * @static
 * @returns {Object}
 */
ozpIwc.ApiPromiseMixin.getCore = function() {
    return {

        /**
         * @property promiseCallbacks
         * @type Object
         * @default {}
         */
        promiseCallbacks: {},

        /**
         * @property msgIdSequence
         * @type Number
         * @default 0
         */
        msgIdSequence: 0,

        /**
         * @property receivedPackets
         * @type Number
         * @default 0
         */
        receivedPackets: 0,

        /**
         * @property receivedBytes
         * @type Number
         * @default 0
         */
        receivedBytes: 0,

        /**
         * @property sentPackets
         * @type Number
         * @default 0
         */
        sentPackets: 0,

        /**
         * @property sentBytes
         * @type Number
         * @default 0
         */
        sentBytes: 0,

        /**
         * The epoch time the Client was instantiated.
         * @property startTime
         * @type Number
         */
        startTime: ozpIwc.util.now(),

        /**
         * A map of available apis and their actions.
         * @property apiMap
         * @type Object
         */
        apiMap: ozpIwc.apiMap || {},

        /**
         * @property wrapperMap
         * @type Object
         * @default {}
         */
        wrapperMap: {},

        /**
         * @property preconnectionQueue
         * @type Array
         * @default []
         */
        preconnectionQueue: [],

        /**
         * @property launchParams
         * @type Object
         * @default {}
         */
        launchParams: {},

        /**
         * @property watchMsgMap
         * @type Object
         * @default {}
         */
        watchMsgMap: {},

        /**
         * @property registeredCallbacks
         * @type Object
         * @default {}
         */
        registeredCallbacks: {},

        /**
         * @property launchedIntents
         * @type Array
         * @default []
         */
        launchedIntents: [],

        /**
         * Returns whether or not the participant is connected to the IWC bus.
         *
         * @method isConnected
         * @returns {Boolean}
         */
        isConnected: function(){
            return this.address !== &quot;$nobody&quot;;
        },

        /**
         * Parses launch parameters based on the raw string input it receives.
         *
         * @method readLaunchParams
         * @param {String} rawString
         */
        readLaunchParams: function(rawString) {
            // of the form ozpIwc.VARIABLE=VALUE, where:
            //   VARIABLE is alphanumeric + &quot;_&quot;
            //   VALUE does not contain &amp; or #
            var re=/ozpIwc.(\w+)=([^&amp;#]+)/g;
            var m;
            while((m=re.exec(rawString)) !== null) {
                var params = decodeURIComponent(m[2]);
                try{
                    params = JSON.parse(params);
                } catch(e){
                    // ignore the errors and just pass through the string
                }
                this.launchParams[m[1]]=params;
            }
        },

        /**
         * Receive a packet from the connected peer.  If the packet is a reply, then
         * the callback for that reply is invoked.  Otherwise, it fires a receive event
         *
         * Fires:
         *     - {{#crossLink &quot;ozpIwc.Client/receive:event}}{{/crossLink}}
         *
         * @method receive
         * @protected
         * @param {ozpIwc.TransportPacket} packetContext
         */
        receiveFromRouterImpl: function (packetContext) {
            var handled = false;

            // If no packet, it is likely a $transport packet.
            var packet = packetContext.packet || packetContext;
            //Try and handle this packet as a reply message
            if (packet.src ===&quot;$transport&quot; || packet.replyTo &amp;&amp; this.promiseCallbacks[packet.replyTo]) {

                var replyCancel = false;
                var replyDone = function () {
                    replyCancel = true;
                };
                this.promiseCallbacks[packet.replyTo](packet, replyDone);

                if (replyCancel) {
                    this.cancelPromiseCallback(packet.replyTo);
                    handled = true;
                }

            }

            //Try and handle this packet as callback message
            if (!handled &amp;&amp; packet.replyTo &amp;&amp; this.registeredCallbacks[packet.replyTo]) {

                var registeredCancel = false;
                var registeredDone = function () {
                    registeredCancel = true;
                };

                handled = this.registeredCallbacks[packet.replyTo](packet, registeredDone);
                if (registeredCancel) {
                    if (this.watchMsgMap[packet.replyTo] &amp;&amp; this.watchMsgMap[packet.replyTo].action === &quot;watch&quot;) {
                        this.api(this.watchMsgMap[packet.replyTo].dst).unwatch(this.watchMsgMap[packet.replyTo].resource);
                    }
                    this.cancelRegisteredCallback(packet.replyTo);
                }
            }
            if(!handled){
                // Otherwise trigger &quot;receive&quot; for someone to handle it
                this.events.trigger(&quot;receive&quot;,packetContext);
            }
        },

        /**
         * Builds the client api calls from the values in client.apiMap
         *
         * @method constructApiFunctions
         */
        constructApiFunctions: function () {
            for (var api in this.apiMap) {
                var apiObj = this.apiMap[api];
                var apiFuncName = apiObj.address.replace(&#x27;.api&#x27;, &#x27;&#x27;);

                //prevent overriding client constructed fields, but allow updating of constructed APIs
                if (!this.hasOwnProperty(apiFuncName) || this.apiMap[api].functionName === apiFuncName) {
                    // wrap this in a function to break the closure
                    // on apiObj.address that would otherwise register
                    // everything for the last api in the list
                    /*jshint loopfunc:true*/
                    (function (self, addr) {
                        self[apiFuncName] = function () {
                            return self.api(addr);
                        };
                        self.apiMap[addr] = self.apiMap[addr] || {};
                        self.apiMap[addr].functionName = apiFuncName;
                        self.updateApi(addr);
                    })(this, apiObj.address);
                }
            }
        },

        /**
         * Calls the names.api to gather the /api/* resources to gain knowledge of available api actions of the current bus.
         *
         * @method gatherApiInformation
         * @returns {Promise}
         */
        gatherApiInformation: function () {
            var self = this;
            // gather api information
            return this.send({
                dst: &quot;names.api&quot;,
                action: &quot;get&quot;,
                resource: &quot;/api&quot;
            }).then(function (reply) {
                if (reply.response === &#x27;ok&#x27;) {
                    return reply.entity;
                } else {
                    throw reply.response;
                }
            }).then(function (apis) {
                var promiseArray = [];
                apis.forEach(function (api) {
                    var promise = self.send({
                        dst: &quot;names.api&quot;,
                        action: &quot;get&quot;,
                        resource: api
                    }).then(function (res) {
                        if (res.response === &#x27;ok&#x27;) {
                            var name = api.replace(&#x27;/api/&#x27;, &#x27;&#x27;);
                            self.apiMap[name] = self.apiMap[name] || {};
                            self.apiMap[name].address = name;
                            self.apiMap[name].actions = res.entity.actions;
                        } else {
                            throw res.response;
                        }
                    });
                    promiseArray.push(promise);
                });
                return Promise.all(promiseArray);
            });
        },

        /**
         * Cancel a reply callback registration.
         * @method cancelPromiseCallback
         * @param (String} msgId The packet replyTo ID for which the callback was registered.
         *
         * @return {Boolean} True if the cancel was successful, otherwise false.
         */
        cancelPromiseCallback: function (msgId) {
            var success = false;
            if (msgId) {
                delete this.promiseCallbacks[msgId];
                success = true;
            }
            return success;
        },

        /**
         * Cancel a watch callback registration.
         *
         * @method cancelRegisteredCallback
         * @param (String} msgId The packet replyTo ID for which the callback was registered.
         *
         * @return {Boolean} True if the cancel was successful, otherwise false.
         */
        cancelRegisteredCallback: function (msgId) {
            var success = false;
            if (msgId) {
                delete this.registeredCallbacks[msgId];
                delete this.watchMsgMap[msgId];
                success = true;
            }
            return success;
        },

        /**
         * Registers callbacks
         *
         * @method on
         * @param {String} event The event to call the callback on.
         * @param {Function} callback The function to be called.
         *
         */
        on: function (event, callback) {
            if (event === &quot;connected&quot; &amp;&amp; this.isConnected()) {
                callback(this);
                return;
            }
            return this.events.on.apply(this.events, arguments);
        },

        /**
         * De-registers callbacks
         *
         * @method off
         * @param {String} event The event to call the callback on.
         * @param {Function} callback The function to be called.
         *
         */
        off: function (event, callback) {
            return this.events.off.apply(this.events, arguments);
        },

        /**
         * Handles intent invocation packets. Communicates back with the intents.api to operate the in flight intent state
         * machine.
         *
         * @method intentInvocationHandling
         * @param resource {String} The resource of the packet that sent the intent invocation
         * @param intentResource {String} The in flight intent resource, used internally to operate the in flight intent state machine
         * @param callback {Function} The intent handler&#x27;s callback function
         * @returns {Promise}
         */
        intentInvocationHandling: function (resource, intentResource, intentEntity, callback) {
            var self = this;
            var res;
            var promiseChain;
            callback = callback || function(){};

            if(intentEntity) {
                promiseChain = Promise.resolve(intentEntity);
            } else {
                promiseChain = self.send({
                    dst: &quot;intents.api&quot;,
                    action: &quot;get&quot;,
                    resource: intentResource
                }).then(function(reply){
                    return reply.entity;
                });
            }
            return promiseChain.then(function(response) {
                res = response;
                return self.send({
                    dst: &quot;intents.api&quot;,
                    contentType: response.contentType,
                    action: &quot;set&quot;,
                    resource: intentResource,
                    entity: {
                        handler: {
                            resource: resource,
                            address: self.address
                        },
                        state: &quot;running&quot;
                    }
                });
            }).then(function(){
                // Run the intent handler. Wrapped in a promise chain in case the callback itself is async.
                return callback(res);
            }).then(function (result) {

                // Respond to the inflight resource
                return self.send({
                    dst: &quot;intents.api&quot;,
                    contentType: res.contentType,
                    action: &quot;set&quot;,
                    resource: intentResource,
                    entity: {
                        reply: {
                            &#x27;entity&#x27;: result || {},
                            &#x27;contentType&#x27;: res.intent.type
                        },
                        state: &quot;complete&quot;
                    }
                });
            })[&#x27;catch&#x27;](function(e){
                console.log(&quot;Error in handling intent: &quot;, e, &quot; -- Clearing in-flight intent node:&quot;, intentResource);
                self.send({
                    dst: &quot;intents.api&quot;,
                    resource: intentResource,
                    action: &quot;delete&quot;
                });
            });
        },

        /**
         * Calls the specific api wrapper given an api name specified.
         * If the wrapper does not exist it is created.
         *
         * @method api
         * @param apiName {String} The name of the api.
         * @returns {Function} returns the wrapper call for the given api.
         */
        api: function (apiName) {
            return this.wrapperMap[apiName] || this.updateApi(apiName);
        },
        /**
         * Updates the wrapper map for api use. Whenever functionality is added or removed from the apiMap the
         * updateApi must be called to reflect said changes on the wrapper map.
         *
         * @method updateApi
         * @param apiName {String} The name of the api
         * @returns {Function} returns the wrapper call for the given api.
         */
        updateApi: function (apiName) {

            /**
             * Function generator. Generates API functions given a messageBuilder function.
             * @method augment
             * @param messageBuilder
             * @param client
             * @returns {Function}
             */
            var augment = function (messageBuilder,client) {
                return function (resource, fragment, otherCallback) {
                    var message = messageBuilder(resource,fragment,otherCallback);
                    var packet = message.packet;


                    if (packet.dst === &quot;intents.api&quot; &amp;&amp; packet.action === &quot;register&quot;) {
                        for (var i in client.launchedIntents) {
                            var loadedResource = &#x27;/&#x27; + client.launchedIntents[i].entity.intent.type + &#x27;/&#x27; + client.launchedIntents[i].entity.intent.action;
                            if (resource === loadedResource) {
                                client.intentInvocationHandling(resource, client.launchedIntents[i].resource, message.callback);
                                delete client.launchedIntents[i];
                            }
                        }
                    }
                    return client.send(packet, message.callback);
                };
            };

            /**
             * Function generator. Generates API message formatting functions for a client-destination-action pairing.
             * These are generated for bulk sending capabilities, since the message needs to be formatted but not
             * transmitted until desired.
             *
             * @method messageBuilderAugment
             * @param dst
             * @param action
             * @param client
             * @returns {Function}
             */
            var messageBuilderAugment = function(dst, action, client) {
                return function (resource, fragment, otherCallback) {
                    // If a fragment isn&#x27;t supplied argument #2 should be a callback (if supplied)
                    if (typeof fragment === &quot;function&quot;) {
                        otherCallback = fragment;
                        fragment = {};
                    }
                    var packet = {
                        &#x27;dst&#x27;: dst,
                        &#x27;action&#x27;: action,
                        &#x27;resource&#x27;: resource,
                        &#x27;entity&#x27;: {}
                    };
                    for (var k in fragment) {
                        packet[k] = fragment[k];
                    }
                    var resolve,reject;
                    var sendData = new Promise(function(res,rej){
                        resolve = res;
                        reject = rej;
                    });

                    sendData.packet = client.fixPacket(packet);
                    sendData.callback = otherCallback;
                    sendData.res = resolve;
                    sendData.rej = reject;
                    return sendData;
                };
            };

            var wrapper = this.wrapperMap[apiName] || {};
            if (this.apiMap.hasOwnProperty(apiName)) {
                var api = this.apiMap[apiName];
                wrapper = {};

                /**
                 *  All message formatting calls sits inside the API wrapper&#x27;s messageBuilder object. These
                 *  calls will return a formatted message ready to be sent.
                 *  (e.g: data().messageBuilder.set)
                 */
                wrapper.messageBuilder = {};
                wrapper.messageBuilder.bulkSend = function (messages, otherCallback) {
                    var packet = {
                        &#x27;dst&#x27;: api.address,
                        &#x27;action&#x27;: &quot;bulkSend&quot;,
                        &#x27;resource&#x27;: &quot;/&quot;,
                        &#x27;entity&#x27;: messages
                    };

                    return {
                        &#x27;packet&#x27;: packet,
                        &#x27;callback&#x27;: otherCallback
                    };
                };

                /**
                 * All function calls are on the root level of the API wrapper. These calls will format messages and
                 * then send them to the router.
                 * (e.g: data().set)
                 */
                wrapper.bulkSend = (function (bulkMessageBuilder, client) {
                    return function (messages) {
                        var message = bulkMessageBuilder(messages);
                        return client.send(message.packet, message.callback);
                    };
                })(wrapper.messageBuilder.bulkSend, this);

                /**
                 * Iterate over all mapped function calls and augment their message formatter and function call.
                 */
                for (var i = 0; i &lt; api.actions.length; ++i) {
                    var action = api.actions[i];
                    wrapper.messageBuilder[action] = messageBuilderAugment(api.address, action, this);
                    wrapper[action] = augment(wrapper.messageBuilder[action],this);
                }

                this.wrapperMap[apiName] = wrapper;
            }
            wrapper.apiName = apiName;
            return wrapper;
        },

        /**
         * Applies necessary properties to the packet to be transmitted through the router.
         *
         * @method fixPacket
         * @param {Object} fields
         * @returns {Object}
         */
        fixPacket : function(fields){
            var packet = {
                ver: 1,
                src: fields.src || this.address,
                msgId: fields.msgId || &quot;p:&quot; + this.msgIdSequence++,
                time: fields.time || new Date().getTime()
            };

            for (var k in fields) {
                packet[k] = fields[k] || packet[k];
            }

            if(packet.src === &quot;$nobody&quot;) {
                packet.src = this.address;
            }

            return packet;
        },

        /**
         * Registers callbacks for API request callbacks and promises.
         *
         * @method registerResponses
         * @property {Object} packet
         * @property {Function} callback
         * @property {Function} promiseRes
         * @property {Function} promiseRej
         */
        registerResponses: function(packet,callback,promiseRes,promiseRej){
            var self = this;
            if (callback) {
                this.registeredCallbacks[packet.msgId] = function (reply, done) {
                    // We&#x27;ve received a message that was a promise response but we&#x27;ve aready handled our promise response.
                    if (reply.src === &quot;$transport&quot; || /(ok).*/.test(reply.response) || /(bad|no).*/.test(reply.response)) {
                        // Do noting and let it get sent to the event handler
                        return false;
                    }else if (reply.entity &amp;&amp; reply.entity.inFlightIntent) {
                        self.intentInvocationHandling(packet.resource, reply.entity.inFlightIntent,
                            reply.entity.inFlightIntentEntity, callback);
                    } else {
                        callback(reply, done);
                    }
                    return true;
                };
            }

            //respondOn &quot;all&quot;, &quot;error&quot;, or no value (default all) will register a promise callback.
            if(packet.respondOn !== &quot;none&quot;) {
                this.promiseCallbacks[packet.msgId] = function (reply, done) {
                    if (reply.src === &quot;$transport&quot; || /(ok).*/.test(reply.response)) {
                        done();
                        promiseRes(reply);
                    } else if (/(bad|no).*/.test(reply.response)) {
                        done();
                        promiseRej(reply);
                    } else {
                        // it was not a promise callback
                    }
                };
            }

            if (packet.action === &quot;watch&quot;) {
                this.watchMsgMap[packet.msgId] = packet;
            } else if (packet.action === &quot;unwatch&quot; &amp;&amp; packet.replyTo) {
                this.cancelRegisteredCallback(packet.replyTo);
            }

            if(packet.action === &quot;bulkSend&quot;){
                packet.entity.forEach(function(message) {
                    self.registerResponses(message.packet, message.callback, message.res, message.rej);
                });
            }
        },
        /**
         * Sends a packet through the IWC.
         * Will call the participants sendImpl function.
         *
         * @method send
         * @param {Object} fields properties of the send packet..
         * @param {Function} callback The Callback for any replies. The callback will be persisted if it returns a truth-like
         * @param {Function} preexistingPromiseRes If this send already has a promise resolve registration, use it rather than make a new one.
         * @param {Function} preexistingPromiseRej If this send already has a promise reject registration, use it rather than make a new one.
         * value, canceled if it returns a false-like value.
         */
        send: function (fields, callback, preexistingPromiseRes, preexistingPromiseRej) {
            var promiseRes = preexistingPromiseRes;
            var promiseRej = preexistingPromiseRej;
            var promise = new Promise(function (resolve, reject) {

                if (!promiseRes &amp;&amp; !promiseRej) {
                    promiseRes = resolve;
                    promiseRej = reject;
                }
            });

            if (!(this.isConnected() || fields.dst === &quot;$transport&quot;)) {
                // when send is switched to promises, create the promise first and return it here, as well
                this.preconnectionQueue.push({
                    &#x27;fields&#x27;: fields,
                    &#x27;callback&#x27;: callback,
                    &#x27;promiseRes&#x27;: promiseRes,
                    &#x27;promiseRej&#x27;: promiseRej
                });
                return promise;
            }
            var packet = this.fixPacket(fields);
            this.registerResponses(packet,callback,promiseRes,promiseRej);
            this.sendImpl(packet);
            this.sentBytes += packet.length;
            this.sentPackets++;

            return promise;
        },

        /**
         * Generic handler for a bus connection to handle any queued messages &amp; launch data after its connected.
         * @method afterConnected
         * @returns {Promise}
         */
        afterConnected: function(){
            var self = this;
            // dump any queued sends, trigger that we are fully connected
            self.preconnectionQueue.forEach(function (p) {
                self.send(p.fields, p.callback, p.promiseRes, p.promiseRej);
            });
            self.preconnectionQueue = [];
            if (!self.launchParams.inFlightIntent || self.internal) {
                self.events.trigger(&quot;connected&quot;);
                return Promise.resolve();
            }

            // fetch the inFlightIntent
            return self.intents().get(self.launchParams.inFlightIntent).then(function (response) {
                // If there is an inflight intent that has not already been handled (i.e. page refresh driving to here)
                if (response &amp;&amp; response.entity &amp;&amp; response.entity.intent) {
                    self.launchedIntents.push(response);
                    var launchData = response.entity.entity || {};
                    if (response.response === &#x27;ok&#x27;) {
                        for (var k in launchData) {
                            self.launchParams[k] = launchData[k];
                        }
                    }
                    self.intents().set(self.launchParams.inFlightIntent, {
                        entity: {
                            state: &quot;complete&quot;
                        }
                    });
                }
                self.events.trigger(&quot;connected&quot;);
            })[&#x27;catch&#x27;](function(e){
                console.log(self.launchParams.inFlightIntent, &quot; not handled, reason: &quot;, e);
                self.events.trigger(&quot;connected&quot;);
            });
        }

    };
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
